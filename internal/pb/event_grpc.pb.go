// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: event.proto

package pb

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EventStoreClient is the client API for EventStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventStoreClient interface {
	// Accepts a stream of Events returning a Confirmation when completed.
	AppendEvent(ctx context.Context, opts ...grpc.CallOption) (EventStore_AppendEventClient, error)
	// Accepts a Snapshot event returning a Confirmation when completed.
	AppendSnapshot(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Confirmation, error)
	// Retrieves the Events for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateEvents(ctx context.Context, in *GetAggregateEventsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateEventsClient, error)
	// Retrieves the Snapshots for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateSnapshots(ctx context.Context, in *GetAggregateSnapshotsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateSnapshotsClient, error)
	// Retrieves the Events from a given tracking token. However, if several GetEventsRequests are sent in the stream
	// only first one will create the tracker, others are used for increasing number of permits or blacklisting. Results
	// are streamed rather than returned at once.
	ListEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_ListEventsClient, error)
	// Gets the highest sequence number for a specific aggregate.
	ReadHighestSequenceNr(ctx context.Context, in *ReadHighestSequenceNrRequest, opts ...grpc.CallOption) (*ReadHighestSequenceNrResponse, error)
	// Performs a query on the event store, returns a stream of results. Input is a stream to allow flow control from the
	// client
	QueryEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_QueryEventsClient, error)
	// Retrieves the first token available in event store (typically 0). Returns 0 when no events in store.
	GetFirstToken(ctx context.Context, in *GetFirstTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error)
	// Retrieves the last committed token in event store. Returns -1 when no events in store.
	GetLastToken(ctx context.Context, in *GetLastTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error)
	// Retrieves the token of the first token of an event from specified time in event store. Returns -1 when no events in store.
	GetTokenAt(ctx context.Context, in *GetTokenAtRequest, opts ...grpc.CallOption) (*TrackingToken, error)
}

type eventStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewEventStoreClient(cc grpc.ClientConnInterface) EventStoreClient {
	return &eventStoreClient{cc}
}

func (c *eventStoreClient) AppendEvent(ctx context.Context, opts ...grpc.CallOption) (EventStore_AppendEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventStore_ServiceDesc.Streams[0], "/io.axoniq.axonserver.grpc.event.EventStore/AppendEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreAppendEventClient{stream}
	return x, nil
}

type EventStore_AppendEventClient interface {
	Send(*Event) error
	CloseAndRecv() (*Confirmation, error)
	grpc.ClientStream
}

type eventStoreAppendEventClient struct {
	grpc.ClientStream
}

func (x *eventStoreAppendEventClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventStoreAppendEventClient) CloseAndRecv() (*Confirmation, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Confirmation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) AppendSnapshot(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Confirmation, error) {
	out := new(Confirmation)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/AppendSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) ListAggregateEvents(ctx context.Context, in *GetAggregateEventsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventStore_ServiceDesc.Streams[1], "/io.axoniq.axonserver.grpc.event.EventStore/ListAggregateEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreListAggregateEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventStore_ListAggregateEventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventStoreListAggregateEventsClient struct {
	grpc.ClientStream
}

func (x *eventStoreListAggregateEventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) ListAggregateSnapshots(ctx context.Context, in *GetAggregateSnapshotsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateSnapshotsClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventStore_ServiceDesc.Streams[2], "/io.axoniq.axonserver.grpc.event.EventStore/ListAggregateSnapshots", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreListAggregateSnapshotsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventStore_ListAggregateSnapshotsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventStoreListAggregateSnapshotsClient struct {
	grpc.ClientStream
}

func (x *eventStoreListAggregateSnapshotsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) ListEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_ListEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventStore_ServiceDesc.Streams[3], "/io.axoniq.axonserver.grpc.event.EventStore/ListEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreListEventsClient{stream}
	return x, nil
}

type EventStore_ListEventsClient interface {
	Send(*GetEventsRequest) error
	Recv() (*EventWithToken, error)
	grpc.ClientStream
}

type eventStoreListEventsClient struct {
	grpc.ClientStream
}

func (x *eventStoreListEventsClient) Send(m *GetEventsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventStoreListEventsClient) Recv() (*EventWithToken, error) {
	m := new(EventWithToken)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) ReadHighestSequenceNr(ctx context.Context, in *ReadHighestSequenceNrRequest, opts ...grpc.CallOption) (*ReadHighestSequenceNrResponse, error) {
	out := new(ReadHighestSequenceNrResponse)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/ReadHighestSequenceNr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) QueryEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_QueryEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventStore_ServiceDesc.Streams[4], "/io.axoniq.axonserver.grpc.event.EventStore/QueryEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreQueryEventsClient{stream}
	return x, nil
}

type EventStore_QueryEventsClient interface {
	Send(*QueryEventsRequest) error
	Recv() (*QueryEventsResponse, error)
	grpc.ClientStream
}

type eventStoreQueryEventsClient struct {
	grpc.ClientStream
}

func (x *eventStoreQueryEventsClient) Send(m *QueryEventsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventStoreQueryEventsClient) Recv() (*QueryEventsResponse, error) {
	m := new(QueryEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) GetFirstToken(ctx context.Context, in *GetFirstTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error) {
	out := new(TrackingToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/GetFirstToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) GetLastToken(ctx context.Context, in *GetLastTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error) {
	out := new(TrackingToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/GetLastToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) GetTokenAt(ctx context.Context, in *GetTokenAtRequest, opts ...grpc.CallOption) (*TrackingToken, error) {
	out := new(TrackingToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/GetTokenAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventStoreServer is the server API for EventStore service.
// All implementations must embed UnimplementedEventStoreServer
// for forward compatibility
type EventStoreServer interface {
	// Accepts a stream of Events returning a Confirmation when completed.
	AppendEvent(EventStore_AppendEventServer) error
	// Accepts a Snapshot event returning a Confirmation when completed.
	AppendSnapshot(context.Context, *Event) (*Confirmation, error)
	// Retrieves the Events for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateEvents(*GetAggregateEventsRequest, EventStore_ListAggregateEventsServer) error
	// Retrieves the Snapshots for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateSnapshots(*GetAggregateSnapshotsRequest, EventStore_ListAggregateSnapshotsServer) error
	// Retrieves the Events from a given tracking token. However, if several GetEventsRequests are sent in the stream
	// only first one will create the tracker, others are used for increasing number of permits or blacklisting. Results
	// are streamed rather than returned at once.
	ListEvents(EventStore_ListEventsServer) error
	// Gets the highest sequence number for a specific aggregate.
	ReadHighestSequenceNr(context.Context, *ReadHighestSequenceNrRequest) (*ReadHighestSequenceNrResponse, error)
	// Performs a query on the event store, returns a stream of results. Input is a stream to allow flow control from the
	// client
	QueryEvents(EventStore_QueryEventsServer) error
	// Retrieves the first token available in event store (typically 0). Returns 0 when no events in store.
	GetFirstToken(context.Context, *GetFirstTokenRequest) (*TrackingToken, error)
	// Retrieves the last committed token in event store. Returns -1 when no events in store.
	GetLastToken(context.Context, *GetLastTokenRequest) (*TrackingToken, error)
	// Retrieves the token of the first token of an event from specified time in event store. Returns -1 when no events in store.
	GetTokenAt(context.Context, *GetTokenAtRequest) (*TrackingToken, error)
	mustEmbedUnimplementedEventStoreServer()
}

// UnimplementedEventStoreServer must be embedded to have forward compatible implementations.
type UnimplementedEventStoreServer struct {
}

func (UnimplementedEventStoreServer) AppendEvent(EventStore_AppendEventServer) error {
	return status.Errorf(codes.Unimplemented, "method AppendEvent not implemented")
}
func (UnimplementedEventStoreServer) AppendSnapshot(context.Context, *Event) (*Confirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendSnapshot not implemented")
}
func (UnimplementedEventStoreServer) ListAggregateEvents(*GetAggregateEventsRequest, EventStore_ListAggregateEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListAggregateEvents not implemented")
}
func (UnimplementedEventStoreServer) ListAggregateSnapshots(*GetAggregateSnapshotsRequest, EventStore_ListAggregateSnapshotsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListAggregateSnapshots not implemented")
}
func (UnimplementedEventStoreServer) ListEvents(EventStore_ListEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedEventStoreServer) ReadHighestSequenceNr(context.Context, *ReadHighestSequenceNrRequest) (*ReadHighestSequenceNrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadHighestSequenceNr not implemented")
}
func (UnimplementedEventStoreServer) QueryEvents(EventStore_QueryEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryEvents not implemented")
}
func (UnimplementedEventStoreServer) GetFirstToken(context.Context, *GetFirstTokenRequest) (*TrackingToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFirstToken not implemented")
}
func (UnimplementedEventStoreServer) GetLastToken(context.Context, *GetLastTokenRequest) (*TrackingToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastToken not implemented")
}
func (UnimplementedEventStoreServer) GetTokenAt(context.Context, *GetTokenAtRequest) (*TrackingToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenAt not implemented")
}
func (UnimplementedEventStoreServer) mustEmbedUnimplementedEventStoreServer() {}

// UnsafeEventStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventStoreServer will
// result in compilation errors.
type UnsafeEventStoreServer interface {
	mustEmbedUnimplementedEventStoreServer()
}

func RegisterEventStoreServer(s grpc.ServiceRegistrar, srv EventStoreServer) {
	s.RegisterService(&EventStore_ServiceDesc, srv)
}

func _EventStore_AppendEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventStoreServer).AppendEvent(&eventStoreAppendEventServer{stream})
}

type EventStore_AppendEventServer interface {
	SendAndClose(*Confirmation) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type eventStoreAppendEventServer struct {
	grpc.ServerStream
}

func (x *eventStoreAppendEventServer) SendAndClose(m *Confirmation) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventStoreAppendEventServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventStore_AppendSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).AppendSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/AppendSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).AppendSnapshot(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_ListAggregateEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAggregateEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventStoreServer).ListAggregateEvents(m, &eventStoreListAggregateEventsServer{stream})
}

type EventStore_ListAggregateEventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventStoreListAggregateEventsServer struct {
	grpc.ServerStream
}

func (x *eventStoreListAggregateEventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _EventStore_ListAggregateSnapshots_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAggregateSnapshotsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventStoreServer).ListAggregateSnapshots(m, &eventStoreListAggregateSnapshotsServer{stream})
}

type EventStore_ListAggregateSnapshotsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventStoreListAggregateSnapshotsServer struct {
	grpc.ServerStream
}

func (x *eventStoreListAggregateSnapshotsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _EventStore_ListEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventStoreServer).ListEvents(&eventStoreListEventsServer{stream})
}

type EventStore_ListEventsServer interface {
	Send(*EventWithToken) error
	Recv() (*GetEventsRequest, error)
	grpc.ServerStream
}

type eventStoreListEventsServer struct {
	grpc.ServerStream
}

func (x *eventStoreListEventsServer) Send(m *EventWithToken) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventStoreListEventsServer) Recv() (*GetEventsRequest, error) {
	m := new(GetEventsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventStore_ReadHighestSequenceNr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadHighestSequenceNrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).ReadHighestSequenceNr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/ReadHighestSequenceNr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).ReadHighestSequenceNr(ctx, req.(*ReadHighestSequenceNrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_QueryEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventStoreServer).QueryEvents(&eventStoreQueryEventsServer{stream})
}

type EventStore_QueryEventsServer interface {
	Send(*QueryEventsResponse) error
	Recv() (*QueryEventsRequest, error)
	grpc.ServerStream
}

type eventStoreQueryEventsServer struct {
	grpc.ServerStream
}

func (x *eventStoreQueryEventsServer) Send(m *QueryEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventStoreQueryEventsServer) Recv() (*QueryEventsRequest, error) {
	m := new(QueryEventsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventStore_GetFirstToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFirstTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).GetFirstToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/GetFirstToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).GetFirstToken(ctx, req.(*GetFirstTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_GetLastToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).GetLastToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/GetLastToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).GetLastToken(ctx, req.(*GetLastTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_GetTokenAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).GetTokenAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/GetTokenAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).GetTokenAt(ctx, req.(*GetTokenAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventStore_ServiceDesc is the grpc.ServiceDesc for EventStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventStore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.axoniq.axonserver.grpc.event.EventStore",
	HandlerType: (*EventStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendSnapshot",
			Handler:    _EventStore_AppendSnapshot_Handler,
		},
		{
			MethodName: "ReadHighestSequenceNr",
			Handler:    _EventStore_ReadHighestSequenceNr_Handler,
		},
		{
			MethodName: "GetFirstToken",
			Handler:    _EventStore_GetFirstToken_Handler,
		},
		{
			MethodName: "GetLastToken",
			Handler:    _EventStore_GetLastToken_Handler,
		},
		{
			MethodName: "GetTokenAt",
			Handler:    _EventStore_GetTokenAt_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AppendEvent",
			Handler:       _EventStore_AppendEvent_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ListAggregateEvents",
			Handler:       _EventStore_ListAggregateEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListAggregateSnapshots",
			Handler:       _EventStore_ListAggregateSnapshots_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListEvents",
			Handler:       _EventStore_ListEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "QueryEvents",
			Handler:       _EventStore_QueryEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "event.proto",
}

// EventSchedulerClient is the client API for EventScheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventSchedulerClient interface {
	// Schedule the given event for publication at the given time}. The returned ScheduleToken can be used to cancel the planned publication.
	ScheduleEvent(ctx context.Context, in *ScheduleEventRequest, opts ...grpc.CallOption) (*ScheduleToken, error)
	// Cancel a scheduled event and schedule another in its place.
	RescheduleEvent(ctx context.Context, in *RescheduleEventRequest, opts ...grpc.CallOption) (*ScheduleToken, error)
	// Cancel the publication of a scheduled event. If the events has already been published, this method does nothing.
	CancelScheduledEvent(ctx context.Context, in *CancelScheduledEventRequest, opts ...grpc.CallOption) (*InstructionAck, error)
}

type eventSchedulerClient struct {
	cc grpc.ClientConnInterface
}

func NewEventSchedulerClient(cc grpc.ClientConnInterface) EventSchedulerClient {
	return &eventSchedulerClient{cc}
}

func (c *eventSchedulerClient) ScheduleEvent(ctx context.Context, in *ScheduleEventRequest, opts ...grpc.CallOption) (*ScheduleToken, error) {
	out := new(ScheduleToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventScheduler/ScheduleEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventSchedulerClient) RescheduleEvent(ctx context.Context, in *RescheduleEventRequest, opts ...grpc.CallOption) (*ScheduleToken, error) {
	out := new(ScheduleToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventScheduler/RescheduleEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventSchedulerClient) CancelScheduledEvent(ctx context.Context, in *CancelScheduledEventRequest, opts ...grpc.CallOption) (*InstructionAck, error) {
	out := new(InstructionAck)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventScheduler/CancelScheduledEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventSchedulerServer is the server API for EventScheduler service.
// All implementations must embed UnimplementedEventSchedulerServer
// for forward compatibility
type EventSchedulerServer interface {
	// Schedule the given event for publication at the given time}. The returned ScheduleToken can be used to cancel the planned publication.
	ScheduleEvent(context.Context, *ScheduleEventRequest) (*ScheduleToken, error)
	// Cancel a scheduled event and schedule another in its place.
	RescheduleEvent(context.Context, *RescheduleEventRequest) (*ScheduleToken, error)
	// Cancel the publication of a scheduled event. If the events has already been published, this method does nothing.
	CancelScheduledEvent(context.Context, *CancelScheduledEventRequest) (*InstructionAck, error)
	mustEmbedUnimplementedEventSchedulerServer()
}

// UnimplementedEventSchedulerServer must be embedded to have forward compatible implementations.
type UnimplementedEventSchedulerServer struct {
}

func (UnimplementedEventSchedulerServer) ScheduleEvent(context.Context, *ScheduleEventRequest) (*ScheduleToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScheduleEvent not implemented")
}
func (UnimplementedEventSchedulerServer) RescheduleEvent(context.Context, *RescheduleEventRequest) (*ScheduleToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RescheduleEvent not implemented")
}
func (UnimplementedEventSchedulerServer) CancelScheduledEvent(context.Context, *CancelScheduledEventRequest) (*InstructionAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelScheduledEvent not implemented")
}
func (UnimplementedEventSchedulerServer) mustEmbedUnimplementedEventSchedulerServer() {}

// UnsafeEventSchedulerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventSchedulerServer will
// result in compilation errors.
type UnsafeEventSchedulerServer interface {
	mustEmbedUnimplementedEventSchedulerServer()
}

func RegisterEventSchedulerServer(s grpc.ServiceRegistrar, srv EventSchedulerServer) {
	s.RegisterService(&EventScheduler_ServiceDesc, srv)
}

func _EventScheduler_ScheduleEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSchedulerServer).ScheduleEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventScheduler/ScheduleEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSchedulerServer).ScheduleEvent(ctx, req.(*ScheduleEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventScheduler_RescheduleEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RescheduleEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSchedulerServer).RescheduleEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventScheduler/RescheduleEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSchedulerServer).RescheduleEvent(ctx, req.(*RescheduleEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventScheduler_CancelScheduledEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelScheduledEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSchedulerServer).CancelScheduledEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventScheduler/CancelScheduledEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSchedulerServer).CancelScheduledEvent(ctx, req.(*CancelScheduledEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventScheduler_ServiceDesc is the grpc.ServiceDesc for EventScheduler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventScheduler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.axoniq.axonserver.grpc.event.EventScheduler",
	HandlerType: (*EventSchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ScheduleEvent",
			Handler:    _EventScheduler_ScheduleEvent_Handler,
		},
		{
			MethodName: "RescheduleEvent",
			Handler:    _EventScheduler_RescheduleEvent_Handler,
		},
		{
			MethodName: "CancelScheduledEvent",
			Handler:    _EventScheduler_CancelScheduledEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event.proto",
}

// EventTransformationServiceClient is the client API for EventTransformationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventTransformationServiceClient interface {
	// Returns the list of all transformations.
	Transformations(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EventTransformationService_TransformationsClient, error)
	// Starts a new transformation.
	StartTransformation(ctx context.Context, in *StartTransformationRequest, opts ...grpc.CallOption) (*TransformationId, error)
	// Adds requests to transform an event to a transformation.
	TransformEvents(ctx context.Context, opts ...grpc.CallOption) (EventTransformationService_TransformEventsClient, error)
	// Cancels a transformation before it is applied.
	CancelTransformation(ctx context.Context, in *TransformationId, opts ...grpc.CallOption) (EventTransformationService_CancelTransformationClient, error)
	// Applies the changes from a transformation in the event store.
	ApplyTransformation(ctx context.Context, in *ApplyTransformationRequest, opts ...grpc.CallOption) (EventTransformationService_ApplyTransformationClient, error)
	// Deletes old versions of events updated by a transformation.
	Compact(ctx context.Context, in *CompactionRequest, opts ...grpc.CallOption) (EventTransformationService_CompactClient, error)
}

type eventTransformationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventTransformationServiceClient(cc grpc.ClientConnInterface) EventTransformationServiceClient {
	return &eventTransformationServiceClient{cc}
}

func (c *eventTransformationServiceClient) Transformations(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EventTransformationService_TransformationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventTransformationService_ServiceDesc.Streams[0], "/io.axoniq.axonserver.grpc.event.EventTransformationService/Transformations", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventTransformationServiceTransformationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventTransformationService_TransformationsClient interface {
	Recv() (*Transformation, error)
	grpc.ClientStream
}

type eventTransformationServiceTransformationsClient struct {
	grpc.ClientStream
}

func (x *eventTransformationServiceTransformationsClient) Recv() (*Transformation, error) {
	m := new(Transformation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventTransformationServiceClient) StartTransformation(ctx context.Context, in *StartTransformationRequest, opts ...grpc.CallOption) (*TransformationId, error) {
	out := new(TransformationId)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventTransformationService/StartTransformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventTransformationServiceClient) TransformEvents(ctx context.Context, opts ...grpc.CallOption) (EventTransformationService_TransformEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventTransformationService_ServiceDesc.Streams[1], "/io.axoniq.axonserver.grpc.event.EventTransformationService/TransformEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventTransformationServiceTransformEventsClient{stream}
	return x, nil
}

type EventTransformationService_TransformEventsClient interface {
	Send(*TransformRequest) error
	Recv() (*TransformRequestAck, error)
	grpc.ClientStream
}

type eventTransformationServiceTransformEventsClient struct {
	grpc.ClientStream
}

func (x *eventTransformationServiceTransformEventsClient) Send(m *TransformRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventTransformationServiceTransformEventsClient) Recv() (*TransformRequestAck, error) {
	m := new(TransformRequestAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventTransformationServiceClient) CancelTransformation(ctx context.Context, in *TransformationId, opts ...grpc.CallOption) (EventTransformationService_CancelTransformationClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventTransformationService_ServiceDesc.Streams[2], "/io.axoniq.axonserver.grpc.event.EventTransformationService/CancelTransformation", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventTransformationServiceCancelTransformationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventTransformationService_CancelTransformationClient interface {
	Recv() (*empty.Empty, error)
	grpc.ClientStream
}

type eventTransformationServiceCancelTransformationClient struct {
	grpc.ClientStream
}

func (x *eventTransformationServiceCancelTransformationClient) Recv() (*empty.Empty, error) {
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventTransformationServiceClient) ApplyTransformation(ctx context.Context, in *ApplyTransformationRequest, opts ...grpc.CallOption) (EventTransformationService_ApplyTransformationClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventTransformationService_ServiceDesc.Streams[3], "/io.axoniq.axonserver.grpc.event.EventTransformationService/ApplyTransformation", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventTransformationServiceApplyTransformationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventTransformationService_ApplyTransformationClient interface {
	Recv() (*empty.Empty, error)
	grpc.ClientStream
}

type eventTransformationServiceApplyTransformationClient struct {
	grpc.ClientStream
}

func (x *eventTransformationServiceApplyTransformationClient) Recv() (*empty.Empty, error) {
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventTransformationServiceClient) Compact(ctx context.Context, in *CompactionRequest, opts ...grpc.CallOption) (EventTransformationService_CompactClient, error) {
	stream, err := c.cc.NewStream(ctx, &EventTransformationService_ServiceDesc.Streams[4], "/io.axoniq.axonserver.grpc.event.EventTransformationService/Compact", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventTransformationServiceCompactClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventTransformationService_CompactClient interface {
	Recv() (*empty.Empty, error)
	grpc.ClientStream
}

type eventTransformationServiceCompactClient struct {
	grpc.ClientStream
}

func (x *eventTransformationServiceCompactClient) Recv() (*empty.Empty, error) {
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventTransformationServiceServer is the server API for EventTransformationService service.
// All implementations must embed UnimplementedEventTransformationServiceServer
// for forward compatibility
type EventTransformationServiceServer interface {
	// Returns the list of all transformations.
	Transformations(*empty.Empty, EventTransformationService_TransformationsServer) error
	// Starts a new transformation.
	StartTransformation(context.Context, *StartTransformationRequest) (*TransformationId, error)
	// Adds requests to transform an event to a transformation.
	TransformEvents(EventTransformationService_TransformEventsServer) error
	// Cancels a transformation before it is applied.
	CancelTransformation(*TransformationId, EventTransformationService_CancelTransformationServer) error
	// Applies the changes from a transformation in the event store.
	ApplyTransformation(*ApplyTransformationRequest, EventTransformationService_ApplyTransformationServer) error
	// Deletes old versions of events updated by a transformation.
	Compact(*CompactionRequest, EventTransformationService_CompactServer) error
	mustEmbedUnimplementedEventTransformationServiceServer()
}

// UnimplementedEventTransformationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEventTransformationServiceServer struct {
}

func (UnimplementedEventTransformationServiceServer) Transformations(*empty.Empty, EventTransformationService_TransformationsServer) error {
	return status.Errorf(codes.Unimplemented, "method Transformations not implemented")
}
func (UnimplementedEventTransformationServiceServer) StartTransformation(context.Context, *StartTransformationRequest) (*TransformationId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTransformation not implemented")
}
func (UnimplementedEventTransformationServiceServer) TransformEvents(EventTransformationService_TransformEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method TransformEvents not implemented")
}
func (UnimplementedEventTransformationServiceServer) CancelTransformation(*TransformationId, EventTransformationService_CancelTransformationServer) error {
	return status.Errorf(codes.Unimplemented, "method CancelTransformation not implemented")
}
func (UnimplementedEventTransformationServiceServer) ApplyTransformation(*ApplyTransformationRequest, EventTransformationService_ApplyTransformationServer) error {
	return status.Errorf(codes.Unimplemented, "method ApplyTransformation not implemented")
}
func (UnimplementedEventTransformationServiceServer) Compact(*CompactionRequest, EventTransformationService_CompactServer) error {
	return status.Errorf(codes.Unimplemented, "method Compact not implemented")
}
func (UnimplementedEventTransformationServiceServer) mustEmbedUnimplementedEventTransformationServiceServer() {
}

// UnsafeEventTransformationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventTransformationServiceServer will
// result in compilation errors.
type UnsafeEventTransformationServiceServer interface {
	mustEmbedUnimplementedEventTransformationServiceServer()
}

func RegisterEventTransformationServiceServer(s grpc.ServiceRegistrar, srv EventTransformationServiceServer) {
	s.RegisterService(&EventTransformationService_ServiceDesc, srv)
}

func _EventTransformationService_Transformations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventTransformationServiceServer).Transformations(m, &eventTransformationServiceTransformationsServer{stream})
}

type EventTransformationService_TransformationsServer interface {
	Send(*Transformation) error
	grpc.ServerStream
}

type eventTransformationServiceTransformationsServer struct {
	grpc.ServerStream
}

func (x *eventTransformationServiceTransformationsServer) Send(m *Transformation) error {
	return x.ServerStream.SendMsg(m)
}

func _EventTransformationService_StartTransformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTransformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventTransformationServiceServer).StartTransformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventTransformationService/StartTransformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventTransformationServiceServer).StartTransformation(ctx, req.(*StartTransformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventTransformationService_TransformEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventTransformationServiceServer).TransformEvents(&eventTransformationServiceTransformEventsServer{stream})
}

type EventTransformationService_TransformEventsServer interface {
	Send(*TransformRequestAck) error
	Recv() (*TransformRequest, error)
	grpc.ServerStream
}

type eventTransformationServiceTransformEventsServer struct {
	grpc.ServerStream
}

func (x *eventTransformationServiceTransformEventsServer) Send(m *TransformRequestAck) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventTransformationServiceTransformEventsServer) Recv() (*TransformRequest, error) {
	m := new(TransformRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventTransformationService_CancelTransformation_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TransformationId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventTransformationServiceServer).CancelTransformation(m, &eventTransformationServiceCancelTransformationServer{stream})
}

type EventTransformationService_CancelTransformationServer interface {
	Send(*empty.Empty) error
	grpc.ServerStream
}

type eventTransformationServiceCancelTransformationServer struct {
	grpc.ServerStream
}

func (x *eventTransformationServiceCancelTransformationServer) Send(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func _EventTransformationService_ApplyTransformation_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ApplyTransformationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventTransformationServiceServer).ApplyTransformation(m, &eventTransformationServiceApplyTransformationServer{stream})
}

type EventTransformationService_ApplyTransformationServer interface {
	Send(*empty.Empty) error
	grpc.ServerStream
}

type eventTransformationServiceApplyTransformationServer struct {
	grpc.ServerStream
}

func (x *eventTransformationServiceApplyTransformationServer) Send(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func _EventTransformationService_Compact_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CompactionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventTransformationServiceServer).Compact(m, &eventTransformationServiceCompactServer{stream})
}

type EventTransformationService_CompactServer interface {
	Send(*empty.Empty) error
	grpc.ServerStream
}

type eventTransformationServiceCompactServer struct {
	grpc.ServerStream
}

func (x *eventTransformationServiceCompactServer) Send(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

// EventTransformationService_ServiceDesc is the grpc.ServiceDesc for EventTransformationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventTransformationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.axoniq.axonserver.grpc.event.EventTransformationService",
	HandlerType: (*EventTransformationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTransformation",
			Handler:    _EventTransformationService_StartTransformation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Transformations",
			Handler:       _EventTransformationService_Transformations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TransformEvents",
			Handler:       _EventTransformationService_TransformEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CancelTransformation",
			Handler:       _EventTransformationService_CancelTransformation_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ApplyTransformation",
			Handler:       _EventTransformationService_ApplyTransformation_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Compact",
			Handler:       _EventTransformationService_Compact_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "event.proto",
}
